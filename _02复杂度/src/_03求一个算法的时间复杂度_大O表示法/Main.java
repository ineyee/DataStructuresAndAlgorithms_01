package _03求一个算法的时间复杂度_大O表示法;

public class Main {
	public static void main(String[] args) {
		
	}
	
	public static void test() {
		/*
		 * 一、我们先来介绍一下什么是大O表示法，然后再看怎么求一个算法的时间复杂度。
		 * 
		 * 参考：
		 * 大O表示法的常见量级（牛逼文章，还有各种算法的复杂度速查表）：https://baijiahao.baidu.com/s?id=1662190834355918541&wfr=spider&for=pc
		 * 
		 * 大O表示法的常见量级有：
		 * 1、常数级：O(1)
		 * 表示该算法的执行时间为一个常量，通常来说只要算法里没有循环语句、递归语句等，那么该算法的时间复杂度就是O(1)，无论这段代码是一行还是成千上万行
		 * 2、线性级：O(n)
		 * 表示该算法的执行时间会随着输入数据的变化而出现线性变化，最常见的就是对输入数据的单层for循环
		 * 3、平方级：O(n^2)
		 * 表示该算法的执行时间会随着输入数据的变化而出现二次增长，最常见的就是对输入数据的双层嵌套循环
		 * 4、立方级：O(n^3)
		 * 表示该算法的执行时间会随着输入数据的变化而出现三次增长，最常见的就是对输入数据的三层嵌套循环，如果嵌套层级不断加深，那么时间复杂度将是O(n^4)、O(n^k)
		 * 5、对数级：O(logn)
		 * 表示该算法的执行时间会随着输入数据的变化而出现对数增长，最常见的就是循环里i不是i++、i--，而是i *= 2、i *= 3、i /= 2、i /= 3之类
		 * 6、线性对数级：O(nlogn)
		 * 就是将时间复杂度为O(logn)的代码循环了n遍，最常见的就是内层循环为对数级，外层循环为线性级的嵌套循环
		 * 7、指数级：O(2^n)
		 * 表示该算法的执行时间会随着输入数据的变化而出现指数级增长，最常见的就是求第N个斐波那契数的递归法那种递归语句
		 * 
		 * 按算法的执行效率来排序：O(1) > O(logn) > O(n) > O(nlogn) > O(n^2) > O(n^3) > O(2^n)，可参考【大O表示法各量级效率高低图示.png】
		 * 将来如果你估算出一个算法的时间复杂度为排名靠前的4个，那就表明该算法效率还行，可以用；
		 * 但如果排名靠后的3个，那就表明该算法效率不行，最好换一下算法，或者对当前算法通过空间换时间、时间换空间来做优化。
		 * 
		 * 补充，指数和对数是一对逆运算，比如：
		 * y = x ^ n，是指数运算，是用来求幂的，y叫作幂，x叫作底数，n叫作指数
		 * n = logx(y)，是对数运算，是用来求指数的
		 */
	}
	
	public static void test1() {
		/*
		 * 二、怎么求一个算法的时间复杂度?
		 * 
		 * 参考：
		 * 怎么求一个算法的时间复杂度：https://www.cnblogs.com/wonker/p/11236988.html
		 * 
		 * 第一步：找出算法中的基本语句以及基本语句的执行体
		 * 所谓基本语句就是指它的执行体执行次数最多的语句，而语句分为三大类顺序语句、条件语句、循环语句，
		 * 顺序语句的执行体就是这条语句本身，条件语句和循环语句的执行体就是大括号里面的东西。那么因为顺
		 * 序语句和条件语句的执行体都是只会执行1次，而循环语句的执行体通常会执行>=1次，所以【如果算法里有循环，
		 * 那基本语句肯定就是循环语句，更进一步如果存在嵌套循环的话，那基本语句尤指最内层的循环语句，我们直接
		 * 忽略掉顺序语句和条件语句即可；如果算法里没有循环，基本语句才可能是顺序语句和条件语句任选其一，选谁都无所谓，
		 * 因为它们执行体的执行次数都是1】
		 * 当然当算法中有递归语句时，那我们其实就不用关心基本语句是谁了，我们直接跳到第二步看递归函数会被调用多少次即可
		 * 
		 * 第二步：计算基本语句执行体的执行次数
		 * 
		 * 第三步：然后按大O表示法的规则得到基本语句执行体的执行数量级，最后O(执行数量级)就得到了该算法的时间复杂度
		 * 1、如果执行次数是个常数，则执行数量级直接就是1，因此该算法的时间复杂度就是常数级：O(1)
		 * 2、如果执行次数是个对数或线性对数，则执行数量级直接就是logn或nlogn，因此该算法的时间复杂度就是对数级：O(logn)或线性对数级：O(nlogn)
		 * 3、如果执行次数不是上面三种，则忽略掉常数、低阶的全部、最高阶的系数，只保留最高阶的内容即可，最高阶的内容就是
		 * 执行数量级，因此该算法的时间复杂度就是O(执行数量级)
		 */
	}
	
	/*
	 * 第一步：找出算法中的基本语句以及基本语句的执行体
	 * 先看这个算法里有没有循环语句，发现有for循环，所以基本语句就是这个for循环，
	 * for循环的执行体就是那句打印
	 * 
	 * 第二步：计算基本语句执行体的执行次数
	 * for循环的执行体会执行4次
	 * 
	 * 第三步：然后按大O表示法的规则得到基本语句执行体的执行数量级，然后O(执行数量级)就得到了该算法的时间复杂度
	 * 执行次数是个常数4，所以执行数量级为1，因此该算法的时间复杂度就是常数级：O(1)
	 */
	public static void test1_1(int n) {
		System.out.println("test");
		
		if (n > 10) {
			System.out.println("n > 10");
		} else if (n > 5) {
			System.out.println("n > 5");
		} else {
			System.out.println("n <= 5");
		}
		
		for (int i = 0; i < 4; i++) {
			System.out.println("test");
		}
	}
	
	/*
	 * 第一步：找出算法中的基本语句以及基本语句的执行体
	 * 先看这个算法里有没有循环语句，发现有for循环，所以基本语句就是这个for循环，
	 * for循环的执行体就是那句打印
	 * 
	 * 第二步：计算基本语句执行体的执行次数
	 * for循环的执行体会执行n次
	 * 
	 * 第三步：然后按大O表示法的规则得到基本语句执行体的执行数量级，然后O(执行数量级)就得到了该算法的时间复杂度
	 * 执行次数是n，没有常数和低阶可省略，它就是最高阶同时也没有系数，因此该算法的时间复杂度就是线性级：O(n)
	 */
	public static void test1_2(int n) {
		for (int i = 0; i < n; i++) {
			System.out.println("test");
		}
	}
	
	/*
	 * 第一步：找出算法中的基本语句以及基本语句的执行体
	 * 先看这个算法里有没有循环语句，发现有for循环，而且还是个嵌套循环，所以基本语句是内层的那个for循环，
	 * 内层for循环的执行体就是那句打印
	 * 
	 * 第二步：计算基本语句执行体的执行次数
	 * 内层for循环的执行体会执行n^2次
	 * 
	 * 第三步：然后按大O表示法的规则得到基本语句执行体的执行数量级，然后O(执行数量级)就得到了该算法的时间复杂度
	 * 执行次数是n^2，没有常数和低阶可省略，它就是最高阶同时也没有系数，因此该算法的时间复杂度就是平方级：O(n^2)
	 */
	public static void test1_3(int n) {
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				System.out.println("test");
			}
		}
	}
	
	/*
	 * 第一步：找出算法中的基本语句以及基本语句的执行体
	 * 先看这个算法里有没有循环语句，发现有for循环，而且还是个嵌套循环，所以基本语句是内层的那个for循环，
	 * 内层for循环的执行体就是那句打印
	 * 
	 * 第二步：计算基本语句执行体的执行次数
	 * 内层for循环的执行体会执行15 * n次
	 * 
	 * 第三步：然后按大O表示法的规则得到基本语句执行体的执行数量级，然后O(执行数量级)就得到了该算法的时间复杂度
	 * 执行次数是15 * n，没有常数和低阶可省略，它就是最高阶但是可以省略系数15，因此该算法的时间复杂度就是线性级：O(n)
	 */
	public static void test1_4(int n) {
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < 15; j++) {
				System.out.println("test");
			}
		}
	}
	
	/*
	 * 第一步：找出算法中的基本语句以及基本语句的执行体
	 * 先看这个算法里有没有循环语句，发现有while循环，所以基本语句就是这个while循环，
	 * while循环的执行体就是那句打印
	 * 
	 * 第二步：计算基本语句执行体的执行次数
	 * 这个while条件是什么意思呢？其实就是看这个n能除以几次2，比如：
	 * n = 8，那8 / 2 = 4(大于0，第1次)，4 / 2 = 2(大于0，第2次)，2 / 2 = 1(大于0，第3次)，1 / 2 = 0(不大于0，没有第4次了)
	 * 所以8能除以几次2其实就是求指数，log2(8) = 3
	 * 
	 * 因此while循环的执行体会执行log2(n)次
	 * 
	 * 第三步：然后按大O表示法的规则得到基本语句执行体的执行数量级，然后O(执行数量级)就得到了该算法的时间复杂度
	 * 该算法的时间复杂度就是对数级：O(logn)
	 */
	public static void test1_5(int n) {
		while ((n /= 2) > 0) {
			System.out.println("test");
		}
	}
	
	/*
	 * 第一步：找出算法中的基本语句以及基本语句的执行体
	 * 同上
	 * 
	 * 第二步：计算基本语句执行体的执行次数
	 * 同上，while循环的执行体会执行log5(n)次
	 * 
	 * 第三步：然后按大O表示法的规则得到基本语句执行体的执行数量级，然后O(执行数量级)就得到了该算法的时间复杂度
	 * 该算法的时间复杂度就是对数级：O(logn)
	 */
	public static void test1_6(int n) {
		while ((n /= 5) > 0) {
			System.out.println("test");
		}
	}
	
	/*
	 * 第一步：找出算法中的基本语句以及基本语句的执行体
	 * 先看这个算法里有没有循环语句，发现有for循环，而且还是个嵌套循环，所以基本语句是内层的那个for循环，
	 * 内层for循环的执行体就是那句打印
	 * 
	 * 第二步：计算基本语句执行体的执行次数
	 * 首先内层for循环会循环n次
	 * 其次外层for循环会循环log2(n)次，这个其实跟test1_5是同理的，只不过这里是判断2乘以2乘以2...多少次
	 * 就乘到n了（因为n是从1开始的），test1_5是反过来n除以2除以2...除以多少次就到0了
	 * 
	 * 因此内层for循环的执行体会执行n * log2(n)次
	 * 
	 * 第三步：然后按大O表示法的规则得到基本语句执行体的执行数量级，然后O(执行数量级)就得到了该算法的时间复杂度
	 * 该算法的时间复杂度就是线性对数级：O(nlogn)
	 */
	public static void test1_7(int n) {
		for (int i = 1; i < n; i *= 2) {
			for (int j = 0; j < n; j++) {
				System.out.println("test");
			}
		}
	}
	
	/*
	 * 当只有一个输入数据n时，我们的基本语句就是一个，即便算法里有多个循环语句，
	 * 但基本语句的定义不是执行体执行次数最多的那个循环语句嘛，所以这里基本语句
	 * 肯定是嵌套的那个for循环了
	 * 
	 * 执行次数为n^2
	 * 所以时间复杂度为平方级：O(n^2)
	 */
	public static void test1_8(int n) {	
		for (int i = 0; i < n; i++) {
			System.out.println("test-1");
		}
		
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				System.out.println("test-2");
			}
		}
	}
	
	/*
	 * 当输入数据有多个时，那我们的基本语句也就对应的有多个，比如这里就有两个基本语句
	 * 
	 * 第一个for循环执行次数为n，第二个for循环执行次数为k，整体的执行次数为（n + k）
	 * 
	 * 所以时间复杂度为线性级：O(n + k)
	 */
	public static void test1_9(int n, int k) {
		for (int i = 0; i < n; i++) {
			System.out.println("test-n");
		}
		
		for (int i = 0; i < k; i++) {
			System.out.println("test-k");
		}
	}
}
