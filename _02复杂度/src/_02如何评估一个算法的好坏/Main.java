package _02如何评估一个算法的好坏;

public class Main {
	public static void main(String[] args) {
		/*
		 * 那我们如何评估一个算法的好坏呢？
		 * 
		 * 第一种方法：我们很容易就能想到通过统计不同算法对同一组输入的计算耗时来判定它们的好坏
		 * 但是这种方法有一下比较明显的缺点：
		 * （1）执行时间严重依赖于硬件（比如你在硬件性能好的设备上测较差的算法，在硬件性能差的设备上
		 * 测较好的算法，从而导致得到的结果适得其反）
		 * （2）执行时间严重依赖于运行时等各种不确定的环境因素（比如你在测试算法1时，CPU占用率刚好低，
		 * 而测试算法2时，CPU占用率却非常高）
		 * （3）虽说是同一组输入，但是这个输入数据的选择很难保证公正性（比如说前面的同样是输入100，算法1
		 * 很可能计算速度高于算法2，但如果换做同样是输入200，则算法2的计算速度很可能又高于算法1，这就会使
		 * 得我们无从判断）
		 * （4）毕竟我们得编写测试代码来统计耗时（最好地当然就是不写代码，我们直接看一下别人的算法就能估算
		 * 出这个算法的好坏）
		 * 
		 * 第二种方法：时间复杂度 + 空间复杂度
		 * （1）时间复杂度：估算一下这段代码程序指令的执行次数————知道了程序指令的执行次数后，因为一条程序指令的执行时间
		 * 又大概是个固定的数值，所以乘以一下执行次数不就是执行时间了嘛，因此估算程序指令的执行次数就是间接地估算程序指令
		 * 的执行时间
		 * 
		 * 注意这里说的程序指令不是指我们写的代码，而是指代码转换后的汇编指令，比如：
		 * for (int i = 0; i < 4; i++) { 
		 * 	System.out.print("test"); 
		 * }
		 * 我们要从计算机执行程序指令的角度来分析一段代码的执行次数，那上面的代码在转换成汇编指令后
		 * 是不会有什么for语句的（if语句、for语句这种条件语句啊、循环语句啊只是给我们开发者用的，汇编里没有这种玩意），
		 * 汇编里其实就是创建一个变量 i = 0，这算执行了一次，i < 4又是条件语句了，不管，因为汇编里不会有这种代码，i++
		 * 会执行4次，打印函数会执行4次，所以上面的代码执行次数应该为1 + 4 + 4 = 9
		 * （2）空间复杂度：估算一下这段代码所需要占用的存储空间————比如需要开辟多少栈空间和堆空间等
		 * 那一个好的算法当然就是时间复杂度低、空间复杂度低了。
		 */
	}
}
